// Session Context - Mant√©m contexto da sess√£o atual para conversa√ß√£o cont√≠nua
// Armazena documentos processados, hist√≥rico de an√°lises, e permite queries espec√≠ficas

class SessionContext {
  constructor() {
    this.processNumber = null;
    this.processInfo = null; // Informa√ß√µes extra√≠das do DOM (partes, classe, assunto, etc)
    this.documents = []; // Lista de documentos descobertos
    this.processedDocuments = []; // Documentos baixados e processados
    this.conversationHistory = []; // Hist√≥rico de perguntas/respostas
    this.lastAnalysis = null; // √öltima an√°lise completa
    this.cache = null; // Refer√™ncia ao DocumentCache
    this.createdAt = new Date();

    console.log('üí¨ LEX: SessionContext inicializado');
  }

  /**
   * Inicializa sess√£o com dados do processo
   * @param {Object} options - Op√ß√µes de inicializa√ß√£o
   */
  initialize(options = {}) {
    this.processNumber = options.processNumber;
    this.processInfo = options.processInfo || null;
    this.documents = options.documents || [];
    this.cache = options.cache || window.DocumentCache;

    console.log(`‚úÖ LEX: Sess√£o inicializada para processo ${this.processNumber}`);
    console.log(`   üìÑ ${this.documents.length} documentos dispon√≠veis`);

    if (this.processInfo) {
      console.log(`   ‚öñÔ∏è Partes: ${this.processInfo.autor || 'N/A'} x ${this.processInfo.reu || 'N/A'}`);
      console.log(`   üìã Classe: ${this.processInfo.classeProcessual || 'N/A'}`);
    }
  }

  /**
   * Adiciona documento processado ao contexto
   * @param {Object} document - Metadados do documento
   * @param {Object} data - Dados processados (texto, tipo, etc)
   */
  addProcessedDocument(document, data) {
    const existing = this.processedDocuments.find(d => d.id === document.id);

    if (!existing) {
      this.processedDocuments.push({
        id: document.id,
        name: document.name,
        type: document.type,
        url: document.url,
        processedAt: new Date(),
        data: {
          texto: data.texto,
          tipo: data.tipo,
          tamanho: data.tamanho,
          paginas: data.paginas
        }
      });

      console.log(`üìå LEX: Documento ${document.id} adicionado ao contexto da sess√£o`);
    }
  }

  /**
   * Define resultado da √∫ltima an√°lise completa
   * @param {Object} analysis - Resultado da an√°lise
   */
  setLastAnalysis(analysis) {
    this.lastAnalysis = {
      content: analysis,
      timestamp: new Date()
    };

    console.log('üìä LEX: An√°lise completa salva no contexto da sess√£o');
  }

  /**
   * Adiciona mensagem ao hist√≥rico de conversa√ß√£o
   * @param {string} role - 'user' ou 'assistant'
   * @param {string} content - Conte√∫do da mensagem
   */
  addToHistory(role, content) {
    this.conversationHistory.push({
      role: role,
      content: content,
      timestamp: new Date()
    });
  }

  /**
   * Busca documento por ID
   * @param {string} documentId - ID do documento
   * @returns {Object|null} Documento encontrado ou null
   */
  getDocument(documentId) {
    return this.processedDocuments.find(d => d.id === documentId);
  }

  /**
   * Busca documento por nome (busca parcial, case-insensitive)
   * @param {string} searchTerm - Termo de busca
   * @returns {Array} Documentos encontrados
   */
  searchDocuments(searchTerm) {
    const term = searchTerm.toLowerCase();

    return this.processedDocuments.filter(doc =>
      doc.name.toLowerCase().includes(term) ||
      doc.id.includes(term)
    );
  }

  /**
   * Lista todos os documentos processados
   * @returns {Array} Lista de documentos com metadados resumidos
   */
  listDocuments() {
    return this.processedDocuments.map(doc => ({
      id: doc.id,
      name: doc.name,
      type: doc.type,
      pages: doc.data.paginas,
      size: doc.data.tamanho
    }));
  }

  /**
   * Obt√©m texto completo de um documento (do cache se dispon√≠vel)
   * @param {string} documentId - ID do documento
   * @returns {Promise<string|null>} Texto do documento ou null
   */
  async getDocumentText(documentId) {
    // Primeiro, verificar se est√° no contexto
    const doc = this.getDocument(documentId);

    if (doc && doc.data.texto) {
      console.log(`‚úÖ LEX: Texto do documento ${documentId} recuperado do contexto`);
      return doc.data.texto;
    }

    // Se n√£o, tentar cache
    if (this.cache) {
      const cached = this.cache.get(documentId);
      if (cached && cached.texto) {
        console.log(`‚úÖ LEX: Texto do documento ${documentId} recuperado do cache`);
        return cached.texto;
      }
    }

    console.warn(`‚ö†Ô∏è LEX: Documento ${documentId} n√£o encontrado no contexto ou cache`);
    return null;
  }

  /**
   * Gera contexto resumido para enviar √† IA em conversa√ß√µes
   * @param {Object} options - Op√ß√µes de gera√ß√£o
   * @returns {string} Contexto formatado
   */
  generateContextSummary(options = {}) {
    const includeFullText = options.includeFullText || false;
    const maxDocuments = options.maxDocuments || 10;

    let context = `# CONTEXTO DO PROCESSO\n\n`;

    // INFORMA√á√ïES DO PROCESSO
    if (this.processInfo) {
      context += `## Informa√ß√µes do Processo\n\n`;
      context += `- **N√∫mero**: ${this.processNumber || 'N/A'}\n`;
      context += `- **Tribunal**: ${this.processInfo.tribunal || 'N/A'}\n`;
      context += `- **Classe**: ${this.processInfo.classeProcessual || 'N/A'}\n`;
      context += `- **Assunto**: ${this.processInfo.assunto || 'N/A'}\n`;
      context += `- **Autor/Requerente**: ${this.processInfo.autor || 'N/A'}\n`;
      context += `- **R√©u/Requerido**: ${this.processInfo.reu || 'N/A'}\n\n`;
    } else {
      context += `## Processo: ${this.processNumber}\n\n`;
    }

    // AN√ÅLISE ANTERIOR (SE HOUVER)
    if (this.lastAnalysis && options.includeLastAnalysis) {
      context += `## An√°lise Anterior\n\n`;
      const analisePreview = JSON.stringify(this.lastAnalysis.content).substring(0, 500);
      context += `${analisePreview}...\n\n`;
    }

    // DOCUMENTOS PROCESSADOS
    context += `## Documentos Processados (${this.processedDocuments.length} total)\n\n`;

    const docs = this.processedDocuments.slice(0, maxDocuments);

    docs.forEach((doc, i) => {
      context += `${i + 1}. **${doc.name}** (ID: ${doc.id})\n`;
      context += `   - Tipo: ${doc.data.tipo}\n`;
      context += `   - P√°ginas: ${doc.data.paginas || 'N/A'}\n`;

      if (includeFullText && doc.data.texto) {
        const preview = doc.data.texto.substring(0, 500);
        context += `   - Preview: ${preview}...\n`;
      }

      context += '\n';
    });

    if (this.processedDocuments.length > maxDocuments) {
      context += `... e mais ${this.processedDocuments.length - maxDocuments} documentos\n\n`;
    }

    // HIST√ìRICO RECENTE (√∫ltimas 3 mensagens)
    if (this.conversationHistory.length > 0 && options.includeHistory) {
      context += `## Hist√≥rico Recente da Conversa\n\n`;
      const recentHistory = this.conversationHistory.slice(-3);
      recentHistory.forEach(msg => {
        context += `- **${msg.role}**: ${msg.content.substring(0, 100)}...\n`;
      });
      context += '\n';
    }

    return context;
  }

  /**
   * Obt√©m estat√≠sticas da sess√£o
   * @returns {Object} Estat√≠sticas
   */
  getStats() {
    return {
      processNumber: this.processNumber,
      totalDocuments: this.documents.length,
      processedDocuments: this.processedDocuments.length,
      conversationMessages: this.conversationHistory.length,
      hasAnalysis: !!this.lastAnalysis,
      sessionAge: Date.now() - this.createdAt.getTime()
    };
  }

  /**
   * Limpa contexto da sess√£o
   */
  clear() {
    this.processNumber = null;
    this.documents = [];
    this.processedDocuments = [];
    this.conversationHistory = [];
    this.lastAnalysis = null;

    console.log('üóëÔ∏è LEX: Contexto da sess√£o limpo');
  }

  /**
   * Verifica se h√° sess√£o ativa
   * @returns {boolean} True se h√° sess√£o ativa
   */
  isActive() {
    return !!this.processNumber && this.processedDocuments.length > 0;
  }
}

// Tornar dispon√≠vel globalmente
if (typeof window !== 'undefined') {
  window.SessionContext = SessionContext;

  // Criar inst√¢ncia global
  if (!window.lexSession) {
    window.lexSession = new SessionContext();
  }

  console.log('‚úÖ LEX: SessionContext carregado com sucesso');
}
