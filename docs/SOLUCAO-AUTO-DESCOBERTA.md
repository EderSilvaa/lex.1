# üöÄ Solu√ß√£o: Auto-Descoberta de Documentos (Qualquer Aba)

**Problema:** Usu√°rio precisa estar na aba "Docs" para rodar an√°lise completa

**Impacto:** üò§ **ATRITO M√ÅXIMO** - Usu√°rio precisa:
1. Navegar no PJe (cliques extras)
2. ENCONTRAR a aba "Docs" (nem sempre √≥bvia)
3. Esperar p√°gina carregar
4. ENT√ÉO clicar em "An√°lise Completa"

---

## üéØ Solu√ß√µes Reais (Testadas e Vi√°veis)

### **‚úÖ SOLU√á√ÉO 1: Fetch Direto da URL de Documentos**

#### **Conceito:**
Em vez de scraping do DOM atual, fazer requisi√ß√£o direta para a p√°gina de documentos:

```javascript
// Descobrir URL da p√°gina de documentos
const processNumber = extrairNumeroProcesso(); // da URL atual
const docsUrl = `${baseUrl}/pje/Processo/ConsultaProcesso/Detalhe/listAutosDigitais.seam?idProcesso=${processId}`;

// Fazer fetch da p√°gina de docs (em background)
const response = await fetch(docsUrl, {
  credentials: 'include' // usa sess√£o atual
});

const html = await response.text();

// Parse do HTML em mem√≥ria (sem estar na aba)
const parser = new DOMParser();
const doc = parser.parseFromString(html, 'text/html');

// Buscar links normalmente
const links = doc.querySelectorAll('a[href*="idProcessoDocumento"]');
```

#### **Vantagens:**
- ‚úÖ **Funciona de QUALQUER aba** (n√£o precisa navegar)
- ‚úÖ Invis√≠vel para o usu√°rio (background)
- ‚úÖ Usa mesma l√≥gica de scraping atual
- ‚úÖ N√£o requer permiss√µes extras
- ‚úÖ R√°pido (~200-500ms)

#### **Desvantagens:**
- ‚ö†Ô∏è Precisa construir URL corretamente
- ‚ö†Ô∏è Pode variar entre tribunais

#### **Implementa√ß√£o:**
```javascript
// src/js/process-crawler.js

async discoverAllDocuments() {
  console.log('üîç LEX: Descobrindo documentos...');

  // ESTRAT√âGIA 1: Tentar scraping do DOM atual (se j√° estiver na aba certa)
  const currentPageDocs = this.discoverViaDomScraping();
  if (currentPageDocs.length > 0) {
    console.log('‚úÖ Documentos encontrados no DOM atual');
    return currentPageDocs;
  }

  // ESTRAT√âGIA 2: Fetch da p√°gina de documentos (SE N√ÉO estiver na aba)
  console.log('üì° Buscando p√°gina de documentos via fetch...');
  return await this.discoverViaFetch();
}

async discoverViaFetch() {
  try {
    // Extrair ID do processo da URL atual
    const processId = this.extractProcessIdFromUrl();
    if (!processId) {
      throw new Error('ID do processo n√£o encontrado na URL');
    }

    // Construir URL da p√°gina de documentos
    const docsUrl = `${this.baseUrl}/pje/Processo/ConsultaProcesso/Detalhe/listAutosDigitais.seam?idProcesso=${processId}`;

    console.log('üì° Fetching:', docsUrl);

    // Fetch com sess√£o autenticada
    const response = await fetch(docsUrl, {
      method: 'GET',
      credentials: 'include',
      headers: {
        'Accept': 'text/html,application/xhtml+xml',
        'Cache-Control': 'no-cache'
      }
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    const html = await response.text();

    // Parse HTML em mem√≥ria
    const parser = new DOMParser();
    const virtualDoc = parser.parseFromString(html, 'text/html');

    // Usar MESMO seletor que j√° funciona
    const pjeDocLinks = virtualDoc.querySelectorAll('a[href*="idProcessoDocumento"]');
    console.log(`üìÑ Encontrados ${pjeDocLinks.length} links via fetch`);

    // Parse dos links (mesma l√≥gica atual)
    return this.parseDocumentLinks(pjeDocLinks);

  } catch (error) {
    console.error('‚ùå Erro no fetch de documentos:', error);
    return [];
  }
}

extractProcessIdFromUrl() {
  // Extrair de URLs como:
  // https://pje.tjpa.jus.br/pje/...?idProcesso=7940963&...
  const url = new URL(window.location.href);
  return url.searchParams.get('idProcesso');
}
```

#### **Teste:**
```javascript
// Funciona de qualquer aba:
// ‚úÖ Aba "Dados do Processo"
// ‚úÖ Aba "Movimenta√ß√µes"
// ‚úÖ Aba "Partes"
// ‚úÖ Aba "Docs" (fallback para scraping direto)

const crawler = new ProcessCrawler();
const docs = await crawler.discoverAllDocuments();
console.log('Documentos:', docs); // 14 docs mesmo sem estar na aba!
```

---

### **‚úÖ SOLU√á√ÉO 2: API Reversa do PJe (Se existir)**

#### **Conceito:**
Alguns sistemas PJe exp√µem APIs JSON internas:

```javascript
// Verificar se existe endpoint JSON
const apiUrl = `${baseUrl}/pje/api/processos/${processId}/documentos`;

const response = await fetch(apiUrl, {
  credentials: 'include',
  headers: {
    'Accept': 'application/json'
  }
});

const documentos = await response.json();
// Retorna array direto: [{id, nome, url, tipo}, ...]
```

#### **Vantagens:**
- ‚úÖ **Mais r√°pido** (JSON √© menor que HTML)
- ‚úÖ **Mais confi√°vel** (estrutura definida)
- ‚úÖ Funciona de qualquer aba
- ‚úÖ Menos parsing necess√°rio

#### **Desvantagens:**
- ‚ùå **Pode n√£o existir** (precisa investigar cada tribunal)
- ‚ùå Pode estar protegida (CSRF token, etc)

#### **Investiga√ß√£o:**
```javascript
// Script para testar no console
async function investigarAPI() {
  const baseUrl = 'https://pje.tjpa.jus.br';
  const processId = new URLSearchParams(window.location.search).get('idProcesso');

  const endpoints = [
    `/pje/api/processos/${processId}/documentos`,
    `/pje/api/processo/${processId}/autos-digitais`,
    `/pje/rest/processos/${processId}/docs`,
    `/pje/services/processo/${processId}/documentos.json`,
  ];

  for (const endpoint of endpoints) {
    console.log('üîç Testando:', endpoint);
    try {
      const response = await fetch(baseUrl + endpoint, {
        credentials: 'include',
        headers: { 'Accept': 'application/json' }
      });

      if (response.ok) {
        const data = await response.json();
        console.log('‚úÖ ENCONTRADO!', endpoint);
        console.log('Dados:', data);
        return { endpoint, data };
      }
    } catch (e) {
      console.log('‚ùå Falhou:', endpoint);
    }
  }

  console.log('‚ö†Ô∏è Nenhuma API JSON encontrada');
}

// Rodar no console do PJe
await investigarAPI();
```

---

### **‚úÖ SOLU√á√ÉO 3: Navega√ß√£o Program√°tica (Fallback)**

#### **Conceito:**
Se fetch n√£o funcionar, navegar programaticamente para aba de docs:

```javascript
async discoverAllDocuments() {
  // Tentar fetch primeiro
  let docs = await this.discoverViaFetch();
  if (docs.length > 0) return docs;

  // Fallback: navegar para aba de docs
  console.log('üîÑ Navegando para aba de documentos...');

  // Encontrar link/bot√£o da aba "Docs"
  const docsTab = document.querySelector('a[href*="listAutosDigitais"], button:contains("Docs")');

  if (docsTab) {
    // Clicar programaticamente
    docsTab.click();

    // Aguardar carregar
    await this.waitForDocumentsLoad();

    // Scraping normal
    return this.discoverViaDomScraping();
  }

  throw new Error('N√£o foi poss√≠vel acessar documentos');
}

async waitForDocumentsLoad() {
  return new Promise((resolve) => {
    const checkInterval = setInterval(() => {
      const docs = document.querySelectorAll('a[href*="idProcessoDocumento"]');
      if (docs.length > 0) {
        clearInterval(checkInterval);
        resolve();
      }
    }, 500);

    // Timeout de 10 segundos
    setTimeout(() => {
      clearInterval(checkInterval);
      resolve();
    }, 10000);
  });
}
```

#### **Vantagens:**
- ‚úÖ Funciona SEMPRE (√∫ltima linha de defesa)
- ‚úÖ N√£o requer constru√ß√£o de URLs
- ‚úÖ V√™ exatamente o que usu√°rio veria

#### **Desvantagens:**
- ‚ö†Ô∏è Vis√≠vel para usu√°rio (aba muda)
- ‚ö†Ô∏è Mais lento (espera carregamento)
- ‚ö†Ô∏è Pode interferir com navega√ß√£o

---

### **‚úÖ SOLU√á√ÉO 4: Background Script + Message Passing**

#### **Conceito:**
Content script manda mensagem para background script fazer fetch:

```javascript
// src/js/content-simple.js
async function descobrirDocumentos() {
  const processId = extrairProcessId();

  // Enviar para background script
  const response = await chrome.runtime.sendMessage({
    action: 'fetchDocumentos',
    processId: processId,
    baseUrl: window.location.origin
  });

  return response.documentos;
}

// src/js/background.js
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === 'fetchDocumentos') {
    fetchDocumentos(request.processId, request.baseUrl)
      .then(docs => sendResponse({ documentos: docs }))
      .catch(err => sendResponse({ error: err.message }));

    return true; // async response
  }
});

async function fetchDocumentos(processId, baseUrl) {
  const url = `${baseUrl}/pje/.../listAutosDigitais.seam?idProcesso=${processId}`;

  // Background script pode fazer fetch sem CORS
  const response = await fetch(url);
  const html = await response.text();

  // Parse e retorna
  return parseDocumentosFromHTML(html);
}
```

#### **Vantagens:**
- ‚úÖ Sem CORS issues
- ‚úÖ Pode usar cookies automaticamente
- ‚úÖ Mais limpo arquiteturalmente

#### **Desvantagens:**
- ‚ö†Ô∏è Mais complexo (2 scripts se comunicando)
- ‚ö†Ô∏è Background script pode ser suspenso (Manifest V3)

---

## üéØ **RECOMENDA√á√ÉO: Solu√ß√£o H√≠brida**

Implementar estrat√©gias em cascata:

```javascript
async discoverAllDocuments() {
  console.log('üîç LEX: Auto-descoberta de documentos...');

  // PRIORIDADE 1: Scraping do DOM atual (mais r√°pido se j√° estiver na aba)
  if (this.isOnDocumentsPage()) {
    console.log('‚úÖ J√° estamos na p√°gina de documentos');
    return this.discoverViaDomScraping();
  }

  // PRIORIDADE 2: Fetch da p√°gina de documentos (invis√≠vel, r√°pido)
  try {
    const docs = await this.discoverViaFetch();
    if (docs.length > 0) {
      console.log('‚úÖ Documentos descobertos via fetch');
      return docs;
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Fetch falhou, tentando API...', error);
  }

  // PRIORIDADE 3: Tentar API JSON (se existir)
  try {
    const docs = await this.discoverViaAPI();
    if (docs.length > 0) {
      console.log('‚úÖ Documentos descobertos via API');
      return docs;
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è API n√£o dispon√≠vel', error);
  }

  // PRIORIDADE 4: Navega√ß√£o program√°tica (fallback vis√≠vel)
  console.log('üîÑ Navegando para p√°gina de documentos...');
  return await this.discoverViaNavigation();
}

isOnDocumentsPage() {
  // Verificar URL ou elementos espec√≠ficos
  return window.location.href.includes('listAutosDigitais') ||
         document.querySelector('a[href*="idProcessoDocumento"]') !== null;
}
```

---

## üìä **Compara√ß√£o de Solu√ß√µes**

| Solu√ß√£o | Velocidade | Invis√≠vel | Complexidade | Confiabilidade |
|---------|-----------|-----------|--------------|----------------|
| **Fetch HTML** | ‚ö°‚ö°‚ö° (500ms) | ‚úÖ SIM | üü¢ Baixa | üü¢ 90% |
| **API JSON** | ‚ö°‚ö°‚ö°‚ö° (200ms) | ‚úÖ SIM | üü° M√©dia | üü° 50% (se existir) |
| **Navega√ß√£o** | ‚ö° (2-5s) | ‚ùå N√ÉO | üü¢ Baixa | üü¢ 95% |
| **Background** | ‚ö°‚ö°‚ö° (500ms) | ‚úÖ SIM | üî¥ Alta | üü° 80% |

---

## üöÄ **Implementa√ß√£o Recomendada (2-3 horas)**

### **Fase 1: Adicionar Fetch (1h)**
```javascript
// Adicionar m√©todo discoverViaFetch() ao ProcessCrawler
// Testar em diferentes abas
// Fallback para m√©todo atual se falhar
```

### **Fase 2: Detector de Aba (30min)**
```javascript
// Adicionar isOnDocumentsPage()
// Otimizar estrat√©gia baseado em onde est√°
```

### **Fase 3: Investigar API (1h)**
```javascript
// Rodar script de investiga√ß√£o
// Se encontrar API JSON, implementar discoverViaAPI()
```

### **Fase 4: Testes (30min)**
```javascript
// Testar de cada aba do processo:
// ‚úÖ Dados do Processo
// ‚úÖ Movimenta√ß√µes
// ‚úÖ Partes
// ‚úÖ Docs
// ‚úÖ Outras abas
```

---

## üéØ **Resultado Esperado**

### **ANTES:**
```
Usu√°rio est√° em: "Dados do Processo"
Para analisar:
  1. Clicar em "Docs" ‚è±Ô∏è (2s + carga)
  2. Esperar carregar ‚è±Ô∏è (1-3s)
  3. Clicar "An√°lise Completa" ‚è±Ô∏è (1s)
  4. Esperar an√°lise ‚è±Ô∏è (60s)

Total: ~66s + navega√ß√£o + atrito
```

### **DEPOIS:**
```
Usu√°rio est√° em: QUALQUER LUGAR
Para analisar:
  1. Ctrl+Shift+A ‚ö° (instant√¢neo)
  2. Esperar an√°lise ‚è±Ô∏è (60s)

Total: 60s (sem atrito!)
```

**Redu√ß√£o:** üìâ **-10% de tempo** + üéØ **-100% de atrito de navega√ß√£o**

---

## üí° **Bonus: An√°lise Autom√°tica ao Abrir Processo**

Se quiser ir al√©m:

```javascript
// Detectar quando usu√°rio abre um processo
if (isProcessPage() && !hasAnalyzedBefore()) {
  // Perguntar ao usu√°rio
  showNotification({
    message: 'ü§ñ Analisar este processo automaticamente?',
    actions: [
      { label: 'Sim', callback: () => iniciarAnaliseCompleta() },
      { label: 'N√£o', callback: () => dismiss() },
      { label: 'Nunca perguntar', callback: () => disableAutoPrompt() }
    ]
  });
}
```

---

## ‚úÖ **Quer que eu implemente agora?**

Posso implementar a **Solu√ß√£o 1 (Fetch)** que:
- ‚úÖ Funciona de qualquer aba
- ‚úÖ Invis√≠vel para usu√°rio
- ‚úÖ 90% de confiabilidade
- ‚úÖ 2-3 horas de implementa√ß√£o

Vamos fazer? üöÄ
